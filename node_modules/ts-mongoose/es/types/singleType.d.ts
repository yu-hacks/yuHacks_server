import { SchemaTypeOpts, Types } from 'mongoose';
import { SubDocument, SubDocumentArray, SubDocumentArrayNoId, SubDocumentNoId, Required, Select } from './_shared';
import { OptionIdDisabled, Optional, Convert, OptionalField, Definition } from './schema';
import { Extract } from './extract';
declare type Primitives = number | string | boolean | Date | Types.ObjectId;
declare type ExtractOptions<T> = T extends {
    options: infer U;
} ? U : never;
declare type RequiredOpt = Record<Required, true>;
declare type SharedTypeOptions = Partial<Record<Required, boolean> & Record<Select, boolean>>;
declare type SharedTypeOptionsWithEnum = SharedTypeOptions & {
    enum?: ReadonlyArray<string>;
};
export declare type TypeOptions<T> = (T extends string ? Omit<SchemaTypeOpts<T>, keyof SharedTypeOptionsWithEnum> & SharedTypeOptionsWithEnum : Omit<SchemaTypeOpts<T>, keyof SharedTypeOptions>) & SharedTypeOptions;
export declare type EnumOrString<T extends {
    enum?: ReadonlyArray<string>;
} | undefined> = T extends {
    enum?: infer U;
} ? U extends ReadonlyArray<string> ? U[number] : string : string;
declare type IsSchemaType<T, IS, NOT> = 0 extends (1 & T) ? NOT : T extends Definition ? IS : NOT;
export declare type ArrayOfElements<T> = IsSchemaType<T, ExtractOptions<T> extends OptionIdDisabled ? SubDocumentArrayNoId<Extract<T> & SubDocumentNoId> : SubDocumentArray<Extract<T> & SubDocument>, Array<T>>;
export declare type ArrElement<T> = T extends Record<OptionalField, infer R> ? R extends (Primitives | Array<any>) ? R : {
    [P in keyof Convert<R>]: Convert<R>[P];
} : T extends (Primitives | Array<any>) ? T : {
    [P in keyof Convert<T>]: Convert<T>[P];
};
export declare type GetSubDocument<T> = ExtractOptions<T> extends OptionIdDisabled ? SubDocumentNoId : SubDocument;
export declare type GetType<Opts, T> = Opts extends RequiredOpt ? T : Optional<T>;
export {};
