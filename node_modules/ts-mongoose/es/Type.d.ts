/// <reference path="plugin.d.ts" />
import { Types } from 'mongoose';
import { Convert, EnumOrString, Extract, GetType, TypeOptions, GetSubDocument, ArrElement } from './types';
export declare const Type: {
    number: <O extends TypeOptions<number>>(options?: O | undefined) => GetType<O, number>;
    boolean: <O_1 extends TypeOptions<boolean>>(options?: O_1 | undefined) => GetType<O_1, boolean>;
    date: <O_2 extends TypeOptions<Date>>(options?: O_2 | undefined) => GetType<O_2, Date>;
    mixed: <O_3 extends TypeOptions<any>>(options?: O_3 | undefined) => GetType<O_3, any>;
    objectId: <O_4 extends TypeOptions<Types.ObjectId>>(options?: O_4 | undefined) => GetType<O_4, Types.ObjectId>;
    string: <O_5 extends Pick<import("mongoose").SchemaTypeOpts<string>, string | number> & Partial<Record<"required", boolean> & Record<"select", boolean>> & {
        enum?: readonly string[] | undefined;
    }>(options?: O_5 | undefined) => GetType<O_5, EnumOrString<O_5>>;
    decimal128: <O_6 extends TypeOptions<Types.Decimal128>>(options?: O_6 | undefined) => GetType<O_6, Types.Decimal128>;
    buffer: <O_7 extends TypeOptions<Types.Buffer>>(options?: O_7 | undefined) => GetType<O_7, Types.Buffer>;
    object: <O_8 extends TypeOptions<object>>(options?: O_8 | undefined) => {
        of<T extends object>(schema: T): GetType<O_8, { [P in keyof Convert<T>]: Convert<T>[P]; }>;
    };
    array: <O_9 extends TypeOptions<any[]>>(options?: O_9 | undefined) => {
        of<T_1>(schema: T_1): GetType<O_9, 0 extends 1 & ArrElement<T_1> ? ArrElement<T_1>[] : ArrElement<T_1> extends Record<"definition", any> ? (ArrElement<T_1> extends {
            options: infer U;
        } ? U : never) extends Record<"_id", false> ? import("./types/_shared").SubDocumentArrayNoId<Extract<ArrElement<T_1>> & import("./types/_shared").SubDocumentNoId> : import("./types/_shared").SubDocumentArray<Extract<ArrElement<T_1>> & import("./types/_shared").SubDocument> : ArrElement<T_1>[]>;
    };
    schema: <O_10 extends TypeOptions<object>>(options?: O_10 | undefined) => {
        of<T_2 extends Record<"definition", any>>(schema: T_2): GetType<O_10, Extract<T_2> & GetSubDocument<T_2>>;
    };
    ref: <T_3>(schema: T_3) => {
        to<TSchema extends Record<"definition", any>>(name: string, refSchema: TSchema): T_3 | (T_3 extends Record<"notRequired", any> ? Record<"notRequired", TSchema["definition"]> : TSchema["definition"]);
    };
};
